---
title: 推荐系统从零单排系列(二)--Item-Based Collaborative Filtering Recommendation Algorithms
date: 2019-04-04 17:34:17
tags: 
    - 推荐系统
    - Item-Based CF
categories: 
    - 推荐系统
---

![](/gallery/cover/developer-4027337_1920.png)

## 摘要
&emsp;&emsp;信息时代面临的一大挑战就是信息过载。如何在海量的信息中找到我们感兴趣，有价值的信息就是推荐系统的责任。推荐系统无处不在，电商领域推荐商品、推荐电影、歌曲等等。今天看的这篇论文是Badrul Sarwar在2001年提出的基于物品的协同过滤推荐算法，引用次数已经超过7800次，是非常经典的推荐系统算法，之后很多工作都以此为基础。

<!-- morek -->

## 发展与挑战
&emsp;&emsp;想要了解算法，先来看看在当时推荐系统有哪些其他主流做法；遇到的问题又是什么；作者提出的新算法又是如何解决这个问题的。

### 主流推荐算法
注意，此处介绍的是在2001年的主流推荐算法。在当时主流的推荐算法包括：

- User-Based CF
- 聚类
- 贝叶斯网络
- Horting

#### 聚类
&emsp;&emsp;使用聚类算法将兴趣相似的用户归为一类，把推荐问题当做是一个分类问题。对于一个待推荐用户U，找到他所属的分类，将该分类下的所有用户的偏好取平均得到新用户的推荐。部分聚类算法还允许同一个用户属于不同的类别，表示用户具有多种不同程度的爱好。这时对新用户的推荐，根据用户属于不同类别的程度，来进行加权平均。该方法的缺点是推荐的物品，个性化程度不强。我们也可以感觉到建模方式较为粗糙。

#### 贝叶斯网络
&emsp;&emsp;贝叶斯网络创建一个网络，节点是一颗决策树，边上是用户的信息。其训练时间较长，但是推断速度非常快。适用于用户兴趣变化不大，模型训练频率不高的场景，不适合用户兴趣变化较快，模型需要快速更新的场景。

#### Horting
&emsp;&emsp;该方法是基于图的。节点代表用户，边代表用户相似度。为用户产生推荐时，从用户节点出发在图上遍历，综合其他用户的喜好为该用户推荐商品。相比于接下来要提到的KNN邻居算法，该方法利用了其他用户的信息，即使是那些没有给Item打分的用户。而KNN近邻算法只考虑了离着最近的几个用户。

#### User-based协同过滤
&emsp;&emsp;基于用户的协同过滤是当时主流的推荐算法，又被称为**k-nearest neighbor collaborative filtering**。第一次接触协同过滤的同学可能会有点晕，其含义是指利用集体的智慧来为个体过滤出它需要的信息。
&emsp;&emsp;算法核心思想是，针对被推荐的用户User，找到和他兴趣最接近的k个“邻居”，然后把邻居喜欢的物品推荐给用户User。人以群分，跟你兴趣相投的人喜欢的东西往往你也会喜欢。

### 问题
对于当时主流的基于用户的协同过滤算法，主要存在两方面的问题：

1. 可扩展性。或者说高性能，在电商中用户和商品数量巨大，而且用户变化相对较快。在上千万级别的用户中找到潜在的邻居，对推荐系统的线上性能提出了巨大的挑战。
1. 推荐质量。推荐质量不够好，很容易让用户对推荐系统失去信心，并产生抵触情绪。

作者提出的基于物品的推荐可以解决上述问题。

## Item-Based协同过滤
### 建模
无论是基于用户还是基于物品的推荐，推荐系统操作的其实都是一个矩阵。该矩阵每一行代表一个用户，每一列代表一个物品。预先获取了用户对部分商品的喜好信息，比如用户直接的评分，购买记录等。如下图所示：
![](/gallery/推荐系统/01F089F0-0E5E-4AF5-AD70-E0A55F6C51ED.png)

待推荐用户记为active user，推荐系统的任务就是从所有的商品中，找到用户潜在的感兴趣的物品，并推荐给他。Item-Based协同过滤的思想就是，找到和物品最相似的邻居，然后给用户推荐之前喜欢过的物品最相近的物品。物以类聚，相似的物品，用户之前喜欢过，类似的物品他很可能也会喜欢。

### 相似度测量
所以，第一个问题就是如何计算物品的相似度。如下图所示，**为了计算两个物品i,j的相似度，先过滤出对两个物品都有打分的用户**。下面提到的所有计算都是在这些用户上进行的。
![](/gallery/推荐系统/77E28FFC-668D-4CF3-AC1C-90F849EAE0EC.png)

#### 余弦相似度
向量i是指用户对i的评分向量。
![](/gallery/推荐系统/C94BDFA9-8D29-4331-B4C0-8922D9E55E39.png)

#### 修正的余弦相似度
余弦相似度有个缺点，由于向量i，向量j是在不同的用户上取的。原始的余弦相似度公式并没有想出不同用户不同量纲的问题。修正的办法是在计算之前，先减去用户的平均打分，以便消除量纲的影响。如下所示：
![](/gallery/推荐系统/DBE088E1-87E8-4A18-8F74-41C4E2702284.png)


#### 相关性相似度
另外一种常用的计算相似度方式是：Pearson-r相关系数。如下所示：
![](/gallery/推荐系统/7503DD69-63B5-4FD0-BA5D-8B5DFC3F145D.png)
把物品i，和物品j的评分，看做是两个变量X，Y。

### 产生推荐
现在计算好了物品之间的相似度，给定一个用户，根据其对物品的评分，给出对该用户的推荐。主要有两种计算方式，如下所示。无论是哪一种，我们既可以给出用户对于特定物品的打分，或者给出一个推荐列表，列表中包含用户最可能感兴趣的物品，TopN。
#### Weighted Sum
给定用户u，和物品i，想要得到用户对该物品的评分。将物品i和用户u喜欢过的物品的相似度作为权重，对原来的评分进行加权求和，得到u对i的评分：
![](/gallery/推荐系统/CFAC5631-ABCB-48C7-80EC-8A83109C4A1E.png)
N代表用户之前评分的物品。最后除以所有相似度和，保证预测范围。

#### Regression
和加权求和类似，只是不再使用原始的相似度，因为在某些情况下相似度不准确。而是使用回归模型来生成相似度。后面实验效果并不好，不再展开。


## 实验
作者还给出了详细的实验，从以下几个方面来研究Item-Based协同过滤算法：

1. 相似度度量方法
2. 推荐生成计算方法
3. 训练集选取比例
4. 推断性能
5. 召回的物品数量

数据集使用的是MovieLens，评估方法使用MAE（Mean Absolute Error）。实验结果及分析如下：

修正后的余弦距离效果最好：
![](/gallery/推荐系统/196C68C0-910A-4D10-BCD2-8C38F97EDDF1.png)


下图中x表示训练集所占比例。Model Size召回的考虑的物品数量。这张图最有意思，告诉我们可以通过只考虑部分的商品就可以获取较好的性能。当然如果不考虑性能的情况下，item-item方式，也就是把所有的物品之间的相似度都计算出来，肯定可以选出最优的。
![](/gallery/推荐系统/826E9181-7531-4D1C-8E82-795E65D92CFD.png)



## 总结
作者提出的Item-Based协同过滤，因为物品的信息相对稳定，所以可以离线预先计算出物品之间的相似度，在线上需要使用的时候查表就可以了。总体来说，基于物品的协同过滤算法效果比基于用户的要好；而且可以通过预计算解决线上的推荐性能问题。

> 由于本人能力和水平有限，有些地方理解不是很透彻，难免有错误或不当之处，还望批评指正。

## Reference
[1]. Item-Based Collaborative Filtering Recommendation Algorithms


